{"version":3,"sources":["util.ts","Board.ts","boggle.ts","App.ts","serviceWorker.js","index.js"],"names":["dom","React","Board","_this","this","props","boardMatrix","map","row","i","key","letter","j","style","maxWidth","maxLength","value","onChange","evt","l","target","match","setBoard","toUpperCase","Component","getRange","val","boardSize","r","getNeighborLetters","col","board","length","coords","findNeighbors","idx","word","prevCoord","usedCoords","neighbors","candidate","x","startBoard","startingCandidates","findLetterCandidates","solveBoard","flattenedBoard","allPossibleWords","w","DICTIONARY","console","log","split","App","state","boggleBoard","words","_this2","margin","alignText","display","justifyContent","marginTop","_ref","_ref2","Object","slicedToArray","setState","concat","toConsumableArray","Infinity","onClick","alert","Boolean","window","location","hostname","ReactDOM","render","react_default","a","createElement","src_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.bb5ea6b0.chunk.js","sourcesContent":["import * as React from \"react\";\n\nexport const dom = React.createElement;","import {Component} from \"react\";\nimport { dom } from \"./util\";\nimport { BoggleBoard, Coordinate } from \"./types\";\n\ntype Props = {\n    boardMatrix: BoggleBoard,\n    setBoard: (coords: Coordinate, letter: string) => void;\n}\n\nclass Board extends Component<Props, {}> {\n    render() {\n        return dom(\"table\", {}, \n            dom(\"tbody\", {},\n            this.props.boardMatrix.map((row: string[], i: number) => \n                dom(\"tr\", {key: i}, \n                    row.map((letter: string, j: number) => \n                        dom(\"td\", {key: j}, \n                            dom(\"input\", {\n                                style: {maxWidth: \"1em\"},\n                                maxLength: 1,\n                                value: letter, \n                                onChange: (evt) => {\n                                    const l = evt.target.value;\n                                    if (l.match(/([a-zA-Z]{1})/)) {\n                                        this.props.setBoard([i, j], l.toUpperCase())\n                                    }\n                                }\n                            })\n                                    \n                        )\n                    )\n                )\n            )\n        ))\n    }\n}\n\nexport default Board;","import * as r from \"ramda\";\nimport { BoggleBoard, Neighbor, Coordinate } from \"./types\";\nimport DICTIONARY from \"./word_compiler/dictionary.json\"\n\nexport const getRange = (val: number, boardSize: number): number[] =>\n  r.range(\n    val > 0 ? val - 1 : val,\n    val < boardSize - 1 ? val + 2 : val + 1\n  )\n\nexport const getNeighborLetters = r.memoizeWith(r.identity, \n  (row: number, col: number, board: BoggleBoard): Neighbor[] => \n    r.unnest(getRange(row, board.length).map(\n      (i: number) => {\n        return getRange(col, board.length).map(\n          (j: number): Neighbor => \n            ({coords: [i, j], letter: board[i][j]})\n        )\n      }\n    )\n  )\n)\n\nexport const findLetterCandidates = (letter: string, board: BoggleBoard): Coordinate[] => \n    r.unnest(r.range(0, board.length).map(\n      (i: number) => \n        r.reject(r.isNil, \n          r.range(0, board.length).map(\n            (j: number) => \n              board[i][j] === letter \n                ? [i, j] \n                : null\n          )\n        )\n    )) as Coordinate[]\n\nexport const findNeighbors = (idx: number, word: string[], prevCoord: Coordinate, usedCoords: Coordinate[], board: BoggleBoard): boolean => {\n  // Base Case; made whole word\n  if (idx === word.length) {\n    return true\n  }\n\n  // Base Case: could not find next letter\n  const neighbors = r.filter(\n    (candidate: Neighbor) => candidate.letter === word[idx] && !r.includes(candidate.coords, usedCoords),\n    getNeighborLetters(prevCoord[0], prevCoord[1], board)\n  )\n\n  if (neighbors.length === 0) {\n    return false\n  }\n\n  // Recursive case: have neighbor candidates to check\n  return r.any((x) => x, neighbors.map(\n    (candidate) => findNeighbors(\n      idx + 1, \n      word, \n      candidate.coords, \n      r.append(candidate.coords, usedCoords),\n      board\n    )\n  ))\n}\n\nexport const startBoard = (word: string[], board: BoggleBoard) => {\n  const startingCandidates = findLetterCandidates(word[0], board)\n  \n  for (let i in startingCandidates) {\n    if (findNeighbors(1, word, startingCandidates[i], [startingCandidates[i]], board)) {\n      return true\n    }\n  }\n  return false \n}\n\nconst filterDictForBoard = (flattenedBoard: string[]) => r.filter(\n  (w: string) => r.includes(w[0], flattenedBoard),\n  DICTIONARY\n)\n\nexport const solveBoard = (board: BoggleBoard): string[] => {\n  const allPossibleWords = filterDictForBoard(r.flatten<string>(board))\n  console.log(allPossibleWords)\n\n  return r.reject(r.isNil, r.uniq(r.map(\n    (word: string) => startBoard(word.split(\"\"), board) ? word : null, allPossibleWords\n    ))\n  ) as string[]\n}","import { Component } from 'react';\nimport Board from \"./Board\"\nimport { dom } from './util';\nimport { solveBoard } from './boggle';\nimport * as r from \"ramda\"\nimport { Coordinate, BoggleBoard } from './types';\n\ntype State = {\n  boggleBoard: BoggleBoard;\n  words: string[]\n}\n\nclass App extends Component<{}, State> {\n  state: State = {\n    boggleBoard: r.range(0, 4).map((i: number) =>\n      r.range(0, 4).map((j: number) => \"\")),\n    words: []\n  }\n\n  render() {\n    return dom(\n      \"div\", {style: {margin: \"5em\", alignText: \"center\"}},\n      dom('div', {style: {display: \"flex\", justifyContent: \"center\"}},\n        dom(\"h1\", {}, \"Let's Solve Boggle!\")\n      ),\n      dom(\"div\", {style: {display: \"flex\", justifyContent: \"center\", marginTop: \"1em\"}},\n        dom(Board, {\n          boardMatrix: this.state.boggleBoard, \n          setBoard: ([i, j]: Coordinate, letter: string) => \n            this.setState({\n              boggleBoard: [\n                ...r.slice(0, i, this.state.boggleBoard),\n                r.update(j, letter, this.state.boggleBoard[i]),\n                ...r.slice(i+1, Infinity, this.state.boggleBoard)\n              ]\n            }) \n        }),\n      ),\n      dom(\"div\", {style: {display: \"flex\", justifyContent: \"center\", marginTop: \"1em\"}},\n        dom(\"button\", {onClick: () => {\n          if (r.any((l: string) => l === \"\", r.flatten<string>(this.state.boggleBoard))) {\n              alert(\"board incomplete\")\n          }\n          else {\n              this.setState({\n                words: solveBoard(this.state.boggleBoard)\n              })\n          }\n      }}, \"Submit Board\")\n        ),\n    dom(\"div\", {style: {display: \"flex\", justifyContent: \"center\", marginTop: \"1em\"}},\n      dom(\"ul\", {},\n        r.map((word: string) => dom(\"li\", {key: word}, word), this.state.words)\n        )\n      )\n\n    )\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n    window.location.hostname === 'localhost' ||\n      // [::1] is the IPv6 localhost address.\n      window.location.hostname === '[::1]' ||\n      // 127.0.0.1/8 is considered localhost for IPv4.\n      window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n      )\n  );\n  \n  export function register(config) {\n    if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n      // The URL constructor is available in all browsers that support SW.\n      const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n      if (publicUrl.origin !== window.location.origin) {\n        // Our service worker won't work if PUBLIC_URL is on a different origin\n        // from what our page is served on. This might happen if a CDN is used to\n        // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n        return;\n      }\n  \n      window.addEventListener('load', () => {\n        const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n  \n        if (isLocalhost) {\n          // This is running on localhost. Let's check if a service worker still exists or not.\n          checkValidServiceWorker(swUrl, config);\n  \n          // Add some additional logging to localhost, pointing developers to the\n          // service worker/PWA documentation.\n          navigator.serviceWorker.ready.then(() => {\n            console.log(\n              'This web app is being served cache-first by a service ' +\n                'worker. To learn more, visit http://bit.ly/CRA-PWA'\n            );\n          });\n        } else {\n          // Is not localhost. Just register service worker\n          registerValidSW(swUrl, config);\n        }\n      });\n    }\n  }\n  \n  function registerValidSW(swUrl, config) {\n    navigator.serviceWorker\n      .register(swUrl)\n      .then(registration => {\n        registration.onupdatefound = () => {\n          const installingWorker = registration.installing;\n          if (installingWorker == null) {\n            return;\n          }\n          installingWorker.onstatechange = () => {\n            if (installingWorker.state === 'installed') {\n              if (navigator.serviceWorker.controller) {\n                // At this point, the updated precached content has been fetched,\n                // but the previous service worker will still serve the older\n                // content until all client tabs are closed.\n                console.log(\n                  'New content is available and will be used when all ' +\n                    'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n                );\n  \n                // Execute callback\n                if (config && config.onUpdate) {\n                  config.onUpdate(registration);\n                }\n              } else {\n                // At this point, everything has been precached.\n                // It's the perfect time to display a\n                // \"Content is cached for offline use.\" message.\n                console.log('Content is cached for offline use.');\n  \n                // Execute callback\n                if (config && config.onSuccess) {\n                  config.onSuccess(registration);\n                }\n              }\n            }\n          };\n        };\n      })\n      .catch(error => {\n        console.error('Error during service worker registration:', error);\n      });\n  }\n  \n  function checkValidServiceWorker(swUrl, config) {\n    // Check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl)\n      .then(response => {\n        // Ensure service worker exists, and that we really are getting a JS file.\n        const contentType = response.headers.get('content-type');\n        if (\n          response.status === 404 ||\n          (contentType != null && contentType.indexOf('javascript') === -1)\n        ) {\n          // No service worker found. Probably a different app. Reload the page.\n          navigator.serviceWorker.ready.then(registration => {\n            registration.unregister().then(() => {\n              window.location.reload();\n            });\n          });\n        } else {\n          // Service worker found. Proceed as normal.\n          registerValidSW(swUrl, config);\n        }\n      })\n      .catch(() => {\n        console.log(\n          'No internet connection found. App is running in offline mode.'\n        );\n      });\n  }\n  \n  export function unregister() {\n    if ('serviceWorker' in navigator) {\n      navigator.serviceWorker.ready.then(registration => {\n        registration.unregister();\n      });\n    }\n  }\n  ","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();"],"sourceRoot":""}