{"version":3,"sources":["util.ts","Board.ts","boggle.ts","App.ts","serviceWorker.js","index.js"],"names":["dom","React","Board","_this","this","props","boardMatrix","map","row","i","key","letter","j","style","maxWidth","maxLength","value","onChange","evt","l","target","match","setBoard","toUpperCase","Component","getNeighborRange","val","boardSize","r","getNeighborLetters","col","board","concat","join","length","coords","findIsWordInBoard","idx","word","prevCoord","usedCoords","neighbors","candidate","x","startBoard","startingCandidates","findLetterCandidates","solveBoard","flattenedBoard","allPossibleWords","w","WORD_LIST","split","App","state","boggleBoard","words","_this2","margin","alignText","display","justifyContent","marginTop","_ref","_ref2","Object","slicedToArray","setState","toConsumableArray","Infinity","onClick","alert","Boolean","window","location","hostname","ReactDOM","render","react_default","a","createElement","src_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"y33sCAEaA,EAAMC,gBCmCJC,mLA3BF,IAAAC,EAAAC,KACL,OAAOJ,EAAI,QAAS,GAChBA,EAAI,QAAS,GACbI,KAAKC,MAAMC,YAAYC,IAAI,SAACC,EAAeC,GAAhB,OACvBT,EAAI,KAAM,CAACU,IAAKD,GACZD,EAAID,IAAI,SAACI,EAAgBC,GAAjB,OACJZ,EAAI,KAAM,CAACU,IAAKE,GACZZ,EAAI,QAAS,CACTa,MAAO,CAACC,SAAU,OAClBC,UAAW,EACXC,MAAOL,EACPM,SAAU,SAACC,GACP,IAAMC,EAAID,EAAIE,OAAOJ,MACjBG,EAAEE,MAAM,oBACRlB,EAAKE,MAAMiB,SAAS,CAACb,EAAGG,GAAIO,EAAEI,iCAflDC,qHCFNC,EAAmB,SAACC,EAAaC,GAAd,OAC/BC,IACEF,EAAM,EAAIA,EAAM,EAAIA,EACpBA,EAAMC,EAAY,EAAID,EAAM,EAAIA,EAAM,IAO7BG,EAAqBD,IAChC,SAACpB,EAAKsB,EAAKC,GAAX,SAAAC,OAAwBxB,EAAxB,KAAAwB,OAA+BF,EAA/B,KAAAE,OAAsCJ,IAAUG,GAAOE,KAAK,OAC5D,SAACzB,EAAasB,EAAaC,GAA3B,OACEH,IAASH,EAAiBjB,EAAKuB,EAAMG,QAAQ3B,IAC3C,SAACE,GACC,OAAOgB,EAAiBK,EAAKC,EAAMG,QAAQ3B,IACzC,SAACK,GAAD,MACG,CAACuB,OAAQ,CAAC1B,EAAGG,GAAID,OAAQoB,EAAMtB,GAAGG,WA6BlCwB,EAAoB,SAApBA,EAAqBC,EAAaC,EAAgBC,EAAuBC,EAA0BT,GAE9G,GAAIM,IAAQC,EAAKJ,OACf,OAAO,EAIT,IAAMO,EAAYb,IAChB,SAACc,GAAD,OAAyBA,EAAU/B,SAAW2B,EAAKD,KAAST,IAAWc,EAAUP,OAAQK,IACzFX,EAAmBU,EAAU,GAAIA,EAAU,GAAIR,IAGjD,OAAyB,IAArBU,EAAUP,QAKPN,IAAM,SAACe,GAAD,OAAOA,GAAGF,EAAUlC,IAC/B,SAACmC,GAAD,OAAeN,EACbC,EAAM,EACNC,EACAI,EAAUP,OACVP,IAASc,EAAUP,OAAQK,GAC3BT,OASOa,EAAa,SAACN,EAAgBP,GACzC,IAAMc,EAnD4B,SAAClC,EAAgBoB,GAAjB,OAChCH,IAASA,IAAQ,EAAGG,EAAMG,QAAQ3B,IAChC,SAACE,GAAD,OACEmB,IAASA,IACPA,IAAQ,EAAGG,EAAMG,QAAQ3B,IACvB,SAACK,GAAD,OACEmB,EAAMtB,GAAGG,KAAOD,EACZ,CAACF,EAAGG,GACJ,WA2CWkC,CAAqBR,EAAK,GAAIP,GAEzD,IAAK,IAAItB,KAAKoC,EACZ,GAAIT,EAAkB,EAAGE,EAAMO,EAAmBpC,GAAI,CAACoC,EAAmBpC,IAAKsB,GAC7E,OAAO,EAGX,OAAO,GAeIgB,EAAa,SAAChB,GACzB,IAT0BiB,EASpBC,GAToBD,EASkBpB,IAAkBG,GATPH,IACvD,SAACsB,GAAD,OAAetB,IAAWsB,EAAE,GAAIF,IAChCG,IASA,OAAOvB,IAASA,IAASA,IAAOA,IAC9B,SAACU,GAAD,OAAkBM,EAAWN,EAAKc,MAAM,IAAKrB,GAASO,EAAO,MAAMW,sBCpDxDI,6MA/CbC,MAAe,CACbC,YAAa3B,IAAQ,EAAG,GAAGrB,IAAI,SAACE,GAAD,OAC7BmB,IAAQ,EAAG,GAAGrB,IAAI,SAACK,GAAD,MAAe,OACnC4C,MAAO,4EAGA,IAAAC,EAAArD,KACP,OAAOJ,EACL,MAAO,CAACa,MAAO,CAAC6C,OAAQ,MAAOC,UAAW,WAC1C3D,EAAI,MAAO,CAACa,MAAO,CAAC+C,QAAS,OAAQC,eAAgB,WACnD7D,EAAI,KAAM,GAAI,wBAEhBA,EAAI,MAAO,CAACa,MAAO,CAAC+C,QAAS,OAAQC,eAAgB,SAAUC,UAAW,QACxE9D,EAAIE,EAAO,CACTI,YAAaF,KAAKkD,MAAMC,YACxBjC,SAAU,SAAAyC,EAAqBpD,GAArB,IAAAqD,EAAAC,OAAAC,EAAA,EAAAD,CAAAF,EAAA,GAAEtD,EAAFuD,EAAA,GAAKpD,EAALoD,EAAA,UACRP,EAAKU,SAAS,CACZZ,YAAW,GAAAvB,OAAAiC,OAAAG,EAAA,EAAAH,CACNrC,IAAQ,EAAGnB,EAAGgD,EAAKH,MAAMC,cADnB,CAET3B,IAAShB,EAAGD,EAAQ8C,EAAKH,MAAMC,YAAY9C,KAFlCwD,OAAAG,EAAA,EAAAH,CAGNrC,IAAQnB,EAAE,EAAG4D,IAAUZ,EAAKH,MAAMC,qBAK/CvD,EAAI,MAAO,CAACa,MAAO,CAAC+C,QAAS,OAAQC,eAAgB,SAAUC,UAAW,QACxE9D,EAAI,SAAU,CAACsE,QAAS,WAClB1C,IAAM,SAACT,GAAD,MAAqB,KAANA,GAAUS,IAAkB6B,EAAKH,MAAMC,cAC5DgB,MAAM,oBAGNd,EAAKU,SAAS,CACZX,MAAOT,EAAWU,EAAKH,MAAMC,iBAGnC,iBAENvD,EAAI,MAAO,CAACa,MAAO,CAAC+C,QAAS,OAAQC,eAAgB,SAAUC,UAAW,QACxE9D,EAAI,KAAM,GACR4B,IAAM,SAACU,GAAD,OAAkBtC,EAAI,KAAM,CAACU,IAAK4B,GAAOA,IAAOlC,KAAKkD,MAAME,iBAxCvDhC,aCAEgD,QACa,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAAStD,MACvB,2DCZRuD,IAASC,OAAOC,EAAAC,EAAAC,cAACC,EAAD,MAASC,SAASC,eAAe,SD2HzC,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.0c277a80.chunk.js","sourcesContent":["import * as React from \"react\";\n\nexport const dom = React.createElement;","import {Component} from \"react\";\nimport { dom } from \"./util\";\nimport { BoggleBoard, Coordinate } from \"./types\";\n\ntype Props = {\n    boardMatrix: BoggleBoard,\n    setBoard: (coords: Coordinate, letter: string) => void;\n}\n\nclass Board extends Component<Props, {}> {\n    render() {\n        return dom(\"table\", {}, \n            dom(\"tbody\", {},\n            this.props.boardMatrix.map((row: string[], i: number) => \n                dom(\"tr\", {key: i}, \n                    row.map((letter: string, j: number) => \n                        dom(\"td\", {key: j}, \n                            dom(\"input\", {\n                                style: {maxWidth: \"1em\"},\n                                maxLength: 1,\n                                value: letter, \n                                onChange: (evt) => {\n                                    const l = evt.target.value;\n                                    if (l.match(/([a-zA-Z]{0,1})/)) {\n                                        this.props.setBoard([i, j], l.toUpperCase())\n                                    }\n                                }\n                            })\n                                    \n                        )\n                    )\n                )\n            )\n        ))\n    }\n}\n\nexport default Board;","import * as r from \"ramda\";\nimport { BoggleBoard, Neighbor, Coordinate } from \"./types\";\nimport WORD_LIST from \"./word_compiler/dictionary.json\"\n\n/**\n * Get a range for iterating through an element's neighbors that stays within the board\n */\n export const getNeighborRange = (val: number, boardSize: number): number[] =>\n  r.range(\n    val > 0 ? val - 1 : val,\n    val < boardSize - 1 ? val + 2 : val + 1\n  )\n\n/**\n * Memoized function to get all neighbor coordinates and letters of a given\n * coordinate set in a board \n*/\nexport const getNeighborLetters = r.memoizeWith(\n  (row, col, board) => `${row}:${col}:${r.flatten(board).join(\",\")}`, \n  (row: number, col: number, board: BoggleBoard): Neighbor[] => \n    r.unnest(getNeighborRange(row, board.length).map(\n      (i: number) => {\n        return getNeighborRange(col, board.length).map(\n          (j: number): Neighbor => \n            ({coords: [i, j], letter: board[i][j]})\n        )\n      }\n    )\n  )\n)\n\n/**\n * Given a first letter and a board, find all coordinates that are \n * starting candidates for spelling out the word\n */\nexport const findLetterCandidates = (letter: string, board: BoggleBoard): Coordinate[] => \n    r.unnest(r.range(0, board.length).map(\n      (i: number) => \n        r.reject(r.isNil, \n          r.range(0, board.length).map(\n            (j: number) => \n              board[i][j] === letter \n                ? [i, j] \n                : null\n          )\n        )\n    )) as Coordinate[]\n\n/**\n * Recursive function checking board matrix for the ability to find a given\n * word. Make sure that next letter in word is attached to previous coordinates used\n * and has not already been used to spell the word\n */    \nexport const findIsWordInBoard = (idx: number, word: string[], prevCoord: Coordinate, usedCoords: Coordinate[], board: BoggleBoard): boolean => {\n  // Base Case; made whole word\n  if (idx === word.length) {\n    return true\n  }\n\n  // Base Case: could not find next letter\n  const neighbors = r.filter(\n    (candidate: Neighbor) => candidate.letter === word[idx] && !r.includes(candidate.coords, usedCoords),\n    getNeighborLetters(prevCoord[0], prevCoord[1], board)\n  )\n\n  if (neighbors.length === 0) {\n    return false\n  }\n\n  // Recursive case: have neighbor candidates to check\n  return r.any((x) => x, neighbors.map(\n    (candidate) => findIsWordInBoard(\n      idx + 1, \n      word, \n      candidate.coords, \n      r.append(candidate.coords, usedCoords),\n      board\n    )\n  ))\n}\n\n/**\n * For every potential first letter spelling a word, find if the word can be spelled\n * in the given boggle board\n */\nexport const startBoard = (word: string[], board: BoggleBoard) => {\n  const startingCandidates = findLetterCandidates(word[0], board)\n  \n  for (let i in startingCandidates) {\n    if (findIsWordInBoard(1, word, startingCandidates[i], [startingCandidates[i]], board)) {\n      return true\n    }\n  }\n  return false \n}\n\n/**\n * To limit the number of words to check, filter the array of dictionary words\n * to only include those that have starting letters in the boggle board\n */\nconst filterDictForBoard = (flattenedBoard: string[]) => r.filter(\n  (w: string) => r.includes(w[0], flattenedBoard),\n  WORD_LIST\n)\n\n/**\n * Given a boggle board find all the words that can be made in it\n */\nexport const solveBoard = (board: BoggleBoard): string[] => {\n  const allPossibleWords = filterDictForBoard(r.flatten<string>(board))\n\n  return r.reject(r.isNil, r.uniq(r.map(\n    (word: string) => startBoard(word.split(\"\"), board) ? word : null, allPossibleWords\n    ))\n  ) as string[]\n}","import { Component } from 'react';\nimport Board from \"./Board\"\nimport { dom } from './util';\nimport { solveBoard } from './boggle';\nimport * as r from \"ramda\"\nimport { Coordinate, BoggleBoard } from './types';\n\ntype State = {\n  boggleBoard: BoggleBoard;\n  words: string[]\n}\n\nclass App extends Component<{}, State> {\n  state: State = {\n    boggleBoard: r.range(0, 4).map((i: number) =>\n      r.range(0, 4).map((j: number) => \"\")),\n    words: []\n  }\n\n  render() {\n    return dom(\n      \"div\", {style: {margin: \"5em\", alignText: \"center\"}},\n      dom('div', {style: {display: \"flex\", justifyContent: \"center\"}},\n        dom(\"h1\", {}, \"Let's Solve Boggle!\")\n      ),\n      dom(\"div\", {style: {display: \"flex\", justifyContent: \"center\", marginTop: \"1em\"}},\n        dom(Board, {\n          boardMatrix: this.state.boggleBoard, \n          setBoard: ([i, j]: Coordinate, letter: string) => \n            this.setState({\n              boggleBoard: [\n                ...r.slice(0, i, this.state.boggleBoard),\n                r.update(j, letter, this.state.boggleBoard[i]),\n                ...r.slice(i+1, Infinity, this.state.boggleBoard)\n              ]\n            }) \n        }),\n      ),\n      dom(\"div\", {style: {display: \"flex\", justifyContent: \"center\", marginTop: \"1em\"}},\n        dom(\"button\", {onClick: () => {\n          if (r.any((l: string) => l === \"\", r.flatten<string>(this.state.boggleBoard))) {\n              alert(\"Board incomplete\")\n          }\n          else {\n              this.setState({\n                words: solveBoard(this.state.boggleBoard)\n              })\n          }\n      }}, \"Submit Board\")\n        ),\n    dom(\"div\", {style: {display: \"flex\", justifyContent: \"center\", marginTop: \"1em\"}},\n      dom(\"ul\", {},\n        r.map((word: string) => dom(\"li\", {key: word}, word), this.state.words)\n        )\n      )\n\n    )\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n    window.location.hostname === 'localhost' ||\n      // [::1] is the IPv6 localhost address.\n      window.location.hostname === '[::1]' ||\n      // 127.0.0.1/8 is considered localhost for IPv4.\n      window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n      )\n  );\n  \n  export function register(config) {\n    if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n      // The URL constructor is available in all browsers that support SW.\n      const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n      if (publicUrl.origin !== window.location.origin) {\n        // Our service worker won't work if PUBLIC_URL is on a different origin\n        // from what our page is served on. This might happen if a CDN is used to\n        // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n        return;\n      }\n  \n      window.addEventListener('load', () => {\n        const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n  \n        if (isLocalhost) {\n          // This is running on localhost. Let's check if a service worker still exists or not.\n          checkValidServiceWorker(swUrl, config);\n  \n          // Add some additional logging to localhost, pointing developers to the\n          // service worker/PWA documentation.\n          navigator.serviceWorker.ready.then(() => {\n            console.log(\n              'This web app is being served cache-first by a service ' +\n                'worker. To learn more, visit http://bit.ly/CRA-PWA'\n            );\n          });\n        } else {\n          // Is not localhost. Just register service worker\n          registerValidSW(swUrl, config);\n        }\n      });\n    }\n  }\n  \n  function registerValidSW(swUrl, config) {\n    navigator.serviceWorker\n      .register(swUrl)\n      .then(registration => {\n        registration.onupdatefound = () => {\n          const installingWorker = registration.installing;\n          if (installingWorker == null) {\n            return;\n          }\n          installingWorker.onstatechange = () => {\n            if (installingWorker.state === 'installed') {\n              if (navigator.serviceWorker.controller) {\n                // At this point, the updated precached content has been fetched,\n                // but the previous service worker will still serve the older\n                // content until all client tabs are closed.\n                console.log(\n                  'New content is available and will be used when all ' +\n                    'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n                );\n  \n                // Execute callback\n                if (config && config.onUpdate) {\n                  config.onUpdate(registration);\n                }\n              } else {\n                // At this point, everything has been precached.\n                // It's the perfect time to display a\n                // \"Content is cached for offline use.\" message.\n                console.log('Content is cached for offline use.');\n  \n                // Execute callback\n                if (config && config.onSuccess) {\n                  config.onSuccess(registration);\n                }\n              }\n            }\n          };\n        };\n      })\n      .catch(error => {\n        console.error('Error during service worker registration:', error);\n      });\n  }\n  \n  function checkValidServiceWorker(swUrl, config) {\n    // Check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl)\n      .then(response => {\n        // Ensure service worker exists, and that we really are getting a JS file.\n        const contentType = response.headers.get('content-type');\n        if (\n          response.status === 404 ||\n          (contentType != null && contentType.indexOf('javascript') === -1)\n        ) {\n          // No service worker found. Probably a different app. Reload the page.\n          navigator.serviceWorker.ready.then(registration => {\n            registration.unregister().then(() => {\n              window.location.reload();\n            });\n          });\n        } else {\n          // Service worker found. Proceed as normal.\n          registerValidSW(swUrl, config);\n        }\n      })\n      .catch(() => {\n        console.log(\n          'No internet connection found. App is running in offline mode.'\n        );\n      });\n  }\n  \n  export function unregister() {\n    if ('serviceWorker' in navigator) {\n      navigator.serviceWorker.ready.then(registration => {\n        registration.unregister();\n      });\n    }\n  }\n  ","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();"],"sourceRoot":""}